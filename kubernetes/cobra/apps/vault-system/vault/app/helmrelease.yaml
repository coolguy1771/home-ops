---
# yaml-language-server: $schema=https://kubernetes-schemas.devbu.io/helm.toolkit.fluxcd.io/helmrelease_v2beta1.json
apiVersion: helm.toolkit.fluxcd.io/v2beta1
kind: HelmRelease
metadata:
  name: vault
  namespace: vault-system
spec:
  interval: 30m
  chart:
    spec:
      chart: vault
      version: 0.25.0
      sourceRef:
        kind: HelmRepository
        name: hashicorp
        namespace: flux-system
  maxHistory: 2
  install:
    remediation:
      retries: 3
  upgrade:
    cleanupOnFail: true
    remediation:
      retries: 3
  uninstall:
    keepHistory: false
  values:
    global:
      enabled: true
      # TLS for end-to-end encrypted transport
      tlsDisable: false
      serverTelemetry:
        # Enable integration with the Prometheus Operator
        # See the top level serverTelemetry section below before enabling this feature.
        prometheusOperator: true
    injector:
      replicas: 1
      leaderElector:
        enabled: true
      metrics:
        enabled: true
      logLevel: "info"
      logFormat: "json"
      revokeOnShutdown: true
      webhook:
        failurePolicy: Ignore
        matchPolicy: Exact
        timeoutSeconds: 30
      failurePolicy: Ignore
      resources:
        requests:
          memory: 256Mi
          cpu: 250m
        limits:
          memory: 256Mi
          cpu: 250m
    server:
      updateStrategyType: "OnDelete"
      logLevel: "info"
      logFormat: "json"
      # Ingress allows ingress services to be created to allow external access
      # from Kubernetes to access Vault pods.
      # If deployment is on OpenShift, the following block is ignored.
      # In order to expose the service, use the route section below
      ingress:
        enabled: true
        labels: {}
          # traffic: external
        annotations: {}
          # |
          # kubernetes.io/ingress.class: nginx
          # kubernetes.io/tls-acme: "true"
          #   or
          # kubernetes.io/ingress.class: nginx
          # kubernetes.io/tls-acme: "true"

        # Optionally use ingressClassName instead of deprecated annotation.
        # See: https://kubernetes.io/docs/concepts/services-networking/ingress/#deprecated-annotation
        ingressClassName: "cilium"

        # As of Kubernetes 1.19, all Ingress Paths must have a pathType configured. The default value below should be sufficient in most cases.
        # See: https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types for other possible values.
        pathType: Prefix

        # When HA mode is enabled and K8s service registration is being used,
        # configure the ingress to point to the Vault active service.
        activeService: true
        hosts:
          - host: vault.286k.co
            paths: []
        ## Extra paths to prepend to the host configuration. This is useful when working with annotation based services.
        extraPaths: []
        # - path: /*
        #   backend:
        #     service:
        #       name: ssl-redirect
        #       port:
        #         number: use-annotation
        tls:
          - secretName: vault-tls
            hosts:
              - vault.286k.co
      readinessProbe:
        enabled: true
        path: "/v1/sys/health?standbyok=true&sealedcode=204&uninitcode=204"
      livenessProbe:
        enabled: true
        path: "/v1/sys/health?standbyok=true"
        initialDelaySeconds: 60
      # extraEnvironmentVars:
      #   VAULT_CACERT: /vault/userconfig/tls-ca/ca.crt
      # extraVolumes:
      #   - type: secret
      #     name: tls-server
      #   - type: secret
      #     name: tls-ca
      #   - type: secret
      #     name: kms-creds
      # authDelegator enables a cluster role binding to be attached to the service
      # account.  This cluster role binding can be used to setup Kubernetes auth
      # method.  https://www.vaultproject.io/docs/auth/kubernetes.html
      authDelegator:
        enabled: true

      # extraArgs is a string containing additional Vault server arguments.
      extraArgs: ""

      # extraPorts is a list of extra ports. Specified as a YAML list.
      # This is useful if you need to add additional ports to the statefulset in dynamic way.
      extraPorts: null
        # - containerPort: 8300
        #   name: http-monitoring

      # extraEnvironmentVars is a list of extra environment variables to set with the stateful set. These could be
      # used to include variables required for auto-unseal.
      # extraEnvironmentVars: {}
      #   # GOOGLE_REGION: global
      #   # GOOGLE_PROJECT: myproject
      #   # GOOGLE_APPLICATION_CREDENTIALS: /vault/userconfig/myproject/myproject-creds.json

      # extraSecretEnvironmentVars is a list of extra environment variables to set with the stateful set.
      # These variables take value from existing Secret objects.
      extraSecretEnvironmentVars:
        - envName: AWS_SECRET_ACCESS_KEY
          secretName: vault-secret
          secretKey: AWS_SECRET_ACCESS_KEY
        - envName: AWS_ACCESS_KEY_ID
          secretName: vault-secret
          secretKey: AWS_ACCESS_KEY_ID
        - envName: VAULT_AWSKMS_SEAL_KEY_ID
          secretName: vault-secret
          secretKey: VAULT_AWSKMS_SEAL_KEY_ID

      # Deprecated: please use 'volumes' instead.
      # extraVolumes is a list of extra volumes to mount. These will be exposed
      # to Vault in the path `/vault/userconfig/<name>/`. The value below is
      # an array of objects, examples are shown below.
      # extraVolumes: []
      #   # - type: secret (or "configMap")
      #   #   name: my-secret
      #   #   path: null # default is `/vault/userconfig`
      # Toleration Settings for server pods
      # This should be either a multi-line string or YAML matching the Toleration array
      # in a PodSpec.
      tolerations: []

      # Enables network policy for server pods
      networkPolicy:
        enabled: false
        egress: []
        # egress:
        # - to:
        #   - ipBlock:
        #       cidr: 10.0.0.0/24
        #   ports:
        #   - protocol: TCP
        #     port: 443

      # Enables a headless service to be used by the Vault Statefulset
      service:
        enabled: true
        # Enable or disable the vault-active service, which selects Vault pods that
        # have labelled themselves as the cluster leader with `vault-active: "true"`
        active:
          enabled: true
        # Enable or disable the vault-standby service, which selects Vault pods that
        # have labelled themselves as a cluster follower with `vault-active: "false"`
        standby:
          enabled: true
        # If enabled, the service selectors will include `app.kubernetes.io/instance: {{ .Release.Name }}`
        # When disabled, services may select Vault pods not deployed from the chart.
        # Does not affect the headless vault-internal service with `ClusterIP: None`
        instanceSelector:
          enabled: true
        # clusterIP controls whether a Cluster IP address is attached to the
        # Vault service within Kubernetes.  By default, the Vault service will
        # be given a Cluster IP address, set to None to disable.  When disabled
        # Kubernetes will create a "headless" service.  Headless services can be
        # used to communicate with pods directly through DNS instead of a round-robin
        # load balancer.
        # clusterIP: None
      # This configures the Vault Statefulset to create a PVC for data
      # storage when using the file or raft backend storage engines.
      # See https://www.vaultproject.io/docs/configuration/storage/index.html to know more
      dataStorage:
        enabled: true
        # Size of the PVC created
        size: 10Gi
        # Location where the PVC will be mounted.
        mountPath: "/vault/data"
        # Name of the storage class to use.  If null it will use the
        # configured default Storage Class.
        storageClass: ceph-rbd
        # Access Mode of the storage device being used for the PVC
        accessMode: ReadWriteOnce
        # Annotations to apply to the PVC
        annotations: {}

      # This configures the Vault Statefulset to create a PVC for audit
      # logs.  Once Vault is deployed, initialized, and unsealed, Vault must
      # be configured to use this for audit logs.  This will be mounted to
      # /vault/audit
      # See https://www.vaultproject.io/docs/audit/index.html to know more
      auditStorage:
        enabled: true
        # Size of the PVC created
        size: 10Gi
        # Location where the PVC will be mounted.
        mountPath: "/vault/audit"
        # Name of the storage class to use.  If null it will use the
        # configured default Storage Class.
        storageClass: ceph-rbd
        # Access Mode of the storage device being used for the PVC
        accessMode: ReadWriteOnce
        # Annotations to apply to the PVC
        annotations: {}


      # Run Vault in "HA" mode. There are no storage requirements unless the audit log
      # persistence is required.  In HA mode Vault will configure itself to use Consul
      # for its storage backend.  The default configuration provided will work the Consul
      # Helm project by default.  It is possible to manually configure Vault to use a
      # different HA backend.
      ha:
        enabled: true
        replicas: 1
        raft:
          # Enables Raft integrated storage
          enabled: true
          # Set the Node Raft ID to the name of the pod
          setNodeId: true
          config: |
            ui = true

            listener "tcp" {
              address = "[::]:8200"
              cluster_address = "[::]:8201"
              # tls_cert_file = "/vault/userconfig/tls-server/fullchain.pem"
              # tls_key_file = "/vault/userconfig/tls-server/server.key"
              # tls_client_ca_file = "/vault/userconfig/tls-server/client-auth-ca.pem"
              # Enable unauthenticated metrics access (necessary for Prometheus Operator)
              telemetry {
                unauthenticated_metrics_access = "true"
              }
            }
            seal "awskms" {
              region     = "us-east-1"
            }
            storage "raft" {
              path = "/vault/data"
                retry_join {
                leader_api_addr = "https://vault-0.vault-internal:8200"
                # leader_ca_cert_file = "/vault/userconfig/tls-ca/ca.crt"
                # leader_client_cert_file = "/vault/userconfig/tls-server/server.crt"
                # leader_client_key_file = "/vault/userconfig/tls-server/server.key"
              }
            }

            service_registration "kubernetes" {}


        # A disruption budget limits the number of pods of a replicated application
        # that are down simultaneously from voluntary disruptions
        disruptionBudget:
          enabled: true

        # maxUnavailable will default to (n/2)-1 where n is the number of
        # replicas. If you'd like a custom value, you can specify an override here.
          maxUnavailable: null


      # Should the server pods run on the host network
      hostNetwork: false

    # Vault UI
    ui:
      # True if you want to create a Service entry for the Vault UI.
      #
      # serviceType can be used to control the type of service created. For
      # example, setting this to "LoadBalancer" will create an external load
      # balancer (for supported K8S installations) to access the UI.
      enabled: true
      publishNotReadyAddresses: true
      # The service should only contain selectors for active Vault pod
      activeVaultPodOnly: true
      serviceType: "ClusterIP"
      serviceNodePort: null
      externalPort: 8200
      targetPort: 8200

      # The externalTrafficPolicy can be set to either Cluster or Local
      # and is only valid for LoadBalancer and NodePort service types.
      # The default value is Cluster.
      # ref: https://kubernetes.io/docs/concepts/services-networking/service/#external-traffic-policy
      externalTrafficPolicy: Cluster

      #loadBalancerSourceRanges:
      #   - 10.0.0.0/16
      #   - 1.78.23.3/32

      # loadBalancerIP:

      # Extra annotations to attach to the ui service
      # This can either be YAML or a YAML-formatted multi-line templated string map
      # of the annotations to apply to the ui service
      annotations: {}

    # secrets-store-csi-driver-provider-vault
    csi:
      # True if you want to install a secrets-store-csi-driver-provider-vault daemonset.
      #
      # Requires installing the secrets-store-csi-driver separately, see:
      # https://github.com/kubernetes-sigs/secrets-store-csi-driver#install-the-secrets-store-csi-driver
      #
      # With the driver and provider installed, you can mount Vault secrets into volumes
      # similar to the Vault Agent injector, and you can also sync those secrets into
      # Kubernetes secrets.
      enabled: false

      image:
        repository: "hashicorp/vault-csi-provider"
        tag: "1.4.0"
        pullPolicy: IfNotPresent

      # volumes is a list of volumes made available to all containers. These are rendered
      # via toYaml rather than pre-processed like the extraVolumes value.
      # The purpose is to make it easy to share volumes between containers.
      volumes: null
      # - name: tls
      #   secret:
      #     secretName: vault-tls

      # volumeMounts is a list of volumeMounts for the main server container. These are rendered
      # via toYaml rather than pre-processed like the extraVolumes value.
      # The purpose is to make it easy to share volumes between containers.
      volumeMounts: null
      # - name: tls
      #   mountPath: "/vault/tls"
      #   readOnly: true

      resources: {}
      # resources:
      #   requests:
      #     cpu: 50m
      #     memory: 128Mi
      #   limits:
      #     cpu: 50m
      #     memory: 128Mi

      # Override the default secret name for the CSI Provider's HMAC key used for
      # generating secret versions.
      hmacSecretName: ""

      # Settings for the daemonSet used to run the provider.
      daemonSet:
        updateStrategy:
          type: RollingUpdate
          maxUnavailable: ""
        # Extra annotations for the daemonSet. This can either be YAML or a
        # YAML-formatted multi-line templated string map of the annotations to apply
        # to the daemonSet.
        annotations: {}
        # Provider host path (must match the CSI provider's path)
        providersDir: "/etc/kubernetes/secrets-store-csi-providers"
        # Kubelet host path
        kubeletRootDir: "/var/lib/kubelet"
        # Extra labels to attach to the vault-csi-provider daemonSet
        # This should be a YAML map of the labels to apply to the csi provider daemonSet
        extraLabels: {}
        # security context for the pod template and container in the csi provider daemonSet
        securityContext:
          pod: {}
          container: {}

      pod:
        # Extra annotations for the provider pods. This can either be YAML or a
        # YAML-formatted multi-line templated string map of the annotations to apply
        # to the pod.
        annotations: {}

        # Toleration Settings for provider pods
        # This should be either a multi-line string or YAML matching the Toleration array
        # in a PodSpec.
        tolerations: []

        # nodeSelector labels for csi pod assignment, formatted as a multi-line string or YAML map.
        # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
        # Example:
        # nodeSelector:
        #   beta.kubernetes.io/arch: amd64
        nodeSelector: {}

        # Affinity Settings
        # This should be either a multi-line string or YAML matching the PodSpec's affinity field.
        affinity: {}

        # Extra labels to attach to the vault-csi-provider pod
        # This should be a YAML map of the labels to apply to the csi provider pod
        extraLabels: {}

      agent:
        enabled: true
        extraArgs: []

        image:
          repository: "hashicorp/vault"
          tag: "1.15.1"
          pullPolicy: IfNotPresent

        logFormat: json
        logLevel: info

        resources: {}
        # resources:
        #   requests:
        #     memory: 256Mi
        #     cpu: 250m
        #   limits:
        #     memory: 256Mi
        #     cpu: 250m

      # Priority class for csi pods
      priorityClassName: ""

      serviceAccount:
        # Extra annotations for the serviceAccount definition. This can either be
        # YAML or a YAML-formatted multi-line templated string map of the
        # annotations to apply to the serviceAccount.
        annotations: {}

        # Extra labels to attach to the vault-csi-provider serviceAccount
        # This should be a YAML map of the labels to apply to the csi provider serviceAccount
        extraLabels: {}

      # Used to configure readinessProbe for the pods.
      readinessProbe:
        # When a probe fails, Kubernetes will try failureThreshold times before giving up
        failureThreshold: 2
        # Number of seconds after the container has started before probe initiates
        initialDelaySeconds: 5
        # How often (in seconds) to perform the probe
        periodSeconds: 5
        # Minimum consecutive successes for the probe to be considered successful after having failed
        successThreshold: 1
        # Number of seconds after which the probe times out.
        timeoutSeconds: 3
      # Used to configure livenessProbe for the pods.
      livenessProbe:
        # When a probe fails, Kubernetes will try failureThreshold times before giving up
        failureThreshold: 2
        # Number of seconds after the container has started before probe initiates
        initialDelaySeconds: 5
        # How often (in seconds) to perform the probe
        periodSeconds: 5
        # Minimum consecutive successes for the probe to be considered successful after having failed
        successThreshold: 1
        # Number of seconds after which the probe times out.
        timeoutSeconds: 3

      # Enables debug logging.
      debug: false

      # Pass arbitrary additional arguments to vault-csi-provider.
      # See https://www.vaultproject.io/docs/platform/k8s/csi/configurations#command-line-arguments
      # for the available command line flags.
      extraArgs: []

    # Vault is able to collect and publish various runtime metrics.
    # Enabling this feature requires setting adding `telemetry{}` stanza to
    # the Vault configuration. There are a few examples included in the `config` sections above.
    #
    # For more information see:
    # https://www.vaultproject.io/docs/configuration/telemetry
    # https://www.vaultproject.io/docs/internals/telemetry
    serverTelemetry:
      # Enable support for the Prometheus Operator. Currently, this chart does not support
      serviceMonitor:
        # Enable deployment of the Vault Server ServiceMonitor CustomResource.
        enabled: true

      prometheusRules:
          enabled: true
          # Some example rules.
          rules:
            - alert: vault-HighResponseTime
              annotations:
                message: The response time of Vault is over 500ms on average over the last 5 minutes.
              expr: vault_core_handle_request{quantile="0.5", namespace="vault-system"} > 500
              for: 5m
              labels:
                severity: warning
            - alert: vault-HighResponseTime
              annotations:
                message: The response time of Vault is over 1s on average over the last 5 minutes.
              expr: vault_core_handle_request{quantile="0.5", namespace="vault-system"} > 1000
              for: 5m
              labels:
                severity: critical
